\chapter{Description of the protocol}
\section{Introduction}
   
   The protocol developed in this project has been designed to garantee secrecy, integrity and authentication for a client-server application. 

   The overall protocol is based on asymmetric encryption. Infact we suppose that the client already has the public key of the server stored on
   its filesystem. The public encryption scheme allows to authenticate the server. The assumption is that just the server knows the private key so, when the client receives a message signed with private key, it is sure that the server has sent it. But, as we know, the asymmetric encryption is too slow so it is used just at beginning to exchange the \textit{session key} and the \textit{mac key}. The first one is used by symmetric cipher to garantee secrecy of communication, the second one is used to garantee integrity. The client is authenticated by application with a login, after the \textit{key exchange} so we assume that client and the server also share a secret quantity wich is the \textit{password}.
\section{Sequence Diagram}
In this paragraph we will see the sequence diagram. 
\begin{itemize}
	\item the symbol E(K,$\cdots$) means encrypted with key K
	\item HMAC$\textsubscript{K}(X)$ means hash-mac over message X with key K
	\item the symbol || means concatenation of messages
\end{itemize}

\begin{sequencediagram}
	\def\unitfactor{1}
	\newinst[0]{cl}{Client}
	\newinst[11]{sr}{Server}
	\mess{cl}{\small1) ClientHello || n\textsubscript{c}}{sr}
	\mess{sr}{\small2) ServerHello || n\textsubscript{s}}{cl}
	\mess{sr}{\small3) E(K\textsubscript{priv}, n\textsubscript{c} || n\textsubscript{s})}{cl}
	\mess{cl}{\small4) E(K\textsubscript{publ}, n\textsubscript{s} || K\textsubscript{sess} || K\textsubscript{mac} || Username || Password)}{sr}
	\mess{sr}{\small5) E(K\textsubscript{sess},Authent OK || n\textsubscript{c}) || HMAC\textsubscript{K\textsubscript{mac}}(E(K\textsubscript{sess},Authent OK || n\textsubscript{c}))}{cl}
	\mess{cl}{\small6) E(K\textsubscript{sess}, Command || n\textsubscript{s+1}) || HMAC\textsubscript{K\textsubscript{mac}}(E(K\textsubscript{sess}, Command || n\textsubscript{s+1}))	}{sr}
	\mess{sr}{\small7) E(K\textsubscript{sess}, Response || n\textsubscript{c+1}) || HMAC\textsubscript{K\textsubscript{mac}}(E(K\textsubscript{sess}, Response || n\textsubscript{c+1})}{cl}
\end{sequencediagram}
\\ \\The $n_c$ is a nonce generated by the client, instead the $n_s$ is a nonce generated by the server. In the sequence diagram we considered the case where the user typed the correct password. If the client authentication fails the message 5 is AUTHENTICATION FAILED and the following messages are absent. Note that in the message 5 there is no encryption because it does not cointain any confidential data but it is provided an hash-mac. It is a means to proof that the message was sent by the server in this execution of the protocol.
%\section{BAN Logic}
\newcommand{\believes}{\mid\equiv}
\newcommand{\sees}{\triangleleft}
\newcommand{\oncesaid}{\mid\sim}
\newcommand{\controls}{\Rightarrow}
\newcommand{\fresh}[1]{\#(#1)}
\newcommand{\combine}[2]{{\langle #1 \rangle}_{#2}}
\newcommand{\encrypt}[2]{{ \{ #1 \} }_{#2}}
\newcommand{\sharekey}[1]{\xleftrightarrow{#1}}
\newcommand{\pubkey}[1]{\xmapsto{#1}}
\newcommand{\secret}[1]{\xleftrightharpoons{#1}}

%\[A \believes B \]
%\[A \sees B \]
%\[A \oncesaid B \]
%\[A \controls B \]
%\[\fresh{X}\]
%\[\combine{X}{Y}\]
%\[\encrypt{X}{Y}\]
%\[A \sharekey{k} B \]
%\[\pubkey{k} B\]
%\[A \secret{k} B\]

\section{Formal Description}
\subsection{Ipothesis}
\begin{itemize}
\item \(\textnormal{C} \believes \fresh{n_c}\)
\item \(\textnormal{S} \believes \fresh{n_s}\)
\item \(\textnormal{C} \believes \textnormal{S} \controls n_s\)
\item \(\textnormal{S} \believes \textnormal{C} \controls n_c\)
\item \(\textnormal{C} \believes \pubkey{K\textsubscript{publ}} \textnormal{S}\)
\item \(\textnormal{S} \believes \textnormal{C} \controls K_{session}\)
\item \(\textnormal{S} \believes \textnormal{C} \controls \fresh{K_{session}}\)
\item \(\textnormal{S} \believes \textnormal{C} \secret{password} \textnormal{S}\)
\end{itemize}

\subsection{Objectives}
\begin{itemize}
\item \(\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}\)
\item \(\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}\)
\item \(\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}\)
\item \(\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}\)
\item \(\textnormal{C} \believes \textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}\)
\item \(\textnormal{C} \believes \textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}\)
\item \(\textnormal{S} \believes \textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}\)
\item \(\textnormal{S} \believes \textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}\)
%\item \(\textnormal{S} \believes \fresh{\textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}}\)
%\item \(\textnormal{S} \believes \fresh{\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}}\)
\item \(\textnormal{C} \believes \textnormal{S}\believes AUTH\:OK\)
\item \(\textnormal{S} \believes \textnormal{C}\believes CMD\)
\item \(\textnormal{C} \believes \textnormal{S}\believes RESP\)
\end{itemize}

\subsection{Idealized Protocol}
\begin{itemize}
	\item \(\textnormal{M3: S} \rightarrow \textnormal{C} \: \encrypt{n_c,n_s}{K\textsubscript{priv}}\)
	\item \(\textnormal{M4: C} \rightarrow \textnormal{S} \: \encrypt{n_s,\textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S},\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S},user,passwd}{K\textsubscript{publ}}\)
	\item \(\textnormal{M5: S} \rightarrow \textnormal{C} \: \encrypt{n_c,AUTH\:OK, \textnormal{C} \sharekey{K\textsubscript{sess }},\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}}{K\textsubscript{sess}}\)
	\item \(\textnormal{M6: C} \rightarrow \textnormal{S} \: \encrypt{n\textsubscript{s+1},CMD}{K\textsubscript{sees}}\)
	\item \(\textnormal{M7: S} \rightarrow \textnormal{C} \: \encrypt{n\textsubscript{c+1},RESP}{K\textsubscript{sess}}\)
\end{itemize}

\subsection{Proof}
In message 3 the client receives the two nonces encrypted with server's private key. If we apply the Message Meaning Rule (1st postulate) we derive
\[ \frac{\textnormal{C} \believes \pubkey{K\textsubscript{publ}} \textnormal{S}, \textnormal{C} \sees \encrypt{n_c,n_s}{K\textsubscript{priv}}}
        {\textnormal{C} \believes \textnormal{S} \oncesaid (n_c,n_s)}\]
By applying the Nonce Verification Rule (2nd postulate) we derive
\[ \frac{\textnormal{C} \believes \fresh{n_c}, \textnormal{C} \believes \textnormal{S} \oncesaid (n_s,n_c)}{\textnormal{C} \believes (n_c,n_s)}\]

\[ \frac{\textnormal{C} \believes (n_c,n_s)}{\textnormal{C} \believes n_c, \textnormal{C} \believes n_s}\]
So after message 3 the client knows the server nonce generated in this instance of protocol. In the message 4 the client sends the K\textsubscript{sess}, and authenticates to the Server. Client and Server have a preshared secret wich is the Password linked to Username. We apply the Message Meaning Rule (1st postulate) to M4.
\[ \frac{\textnormal{S} \believes \textnormal{C} \secret{passw} \textnormal{S}, \textnormal{S} \sees \combine{n_s,\textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S},\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S},Username}{passw}}{\textnormal{S}\believes \textnormal{C} \oncesaid (n_s,\textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{S},\textnormal{Client} \sharekey{K\textsubscript{mac }} \textnormal{S},Username)} \]
Now we apply the Nonce Verification Rule (2nd postulate) to that message.
\[ \frac{\textnormal{S}\believes \fresh{n_s}, \textnormal{S} \believes \textnormal{C} \oncesaid (n_s,\textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S},\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S},Username)}
   {\textnormal{S} \believes \textnormal{C} \believes (n_s,\textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S},\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S},Username)}	\]
The Server believes that Client believes in the session key. Now we apply the Jurisdiction Rule (3rd postulate) to that message.
\[ \frac{\textnormal{S} \believes \textnormal{C} \believes (\textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S},\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}), \textnormal{S} \believes \textnormal{C} \controls (K\textsubscript{sess},K\textsubscript{mac})}
        {\textnormal{S} \believes (\textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S},\textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}) } \]
Now the Server and the Client believe that session key and mac key has been generated in this execution of the protocol. We have proven that
\begin{itemize}
	\item \(\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}\)
	\item \(\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}\)
	\item \(\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}\)
	\item \(\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}\) 
	\item \(\textnormal{S} \believes \textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}\)
	\item \(\textnormal{S} \believes \textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}\)
\end{itemize}
Now the session keys are established. In the idealized protocol we assumed that the client typed the correct password so the message 5 is AUTHENTICATION OK. It is send in plain text but the message 5 also contains the hash-mac of the message. We can apply the message meaning rule.
\[
	\frac{\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{mac }} \textnormal{S}, \textnormal{C} \sees \encrypt{AUTH\:OK}{K\textsubscript{mac}}}
	{\textnormal{C} \believes \textnormal{S} \oncesaid {AUTH\:OK}} 
\]
And by freshness of \(K\textsubscript{mac}\) we can derive that the message 5 has been generated in this execution of the protocol. 
\begin{itemize}
	\item $\textnormal{Client} \believes \textnormal{Server}\believes AUTH\:OK$
\end{itemize}
It is also necessary to proof that commands have been generated in this execution of the protocol.
\[ \frac{\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}, \textnormal{S} \sees \lbrace CMD, n\textsubscript{s+1} \rbrace \textsubscript{K\textsubscript{sess}} }{ \textnormal{S} \believes \textnormal{C} \oncesaid (CMD,n\textsubscript{s+1}) }\]

\[ \frac{ \textnormal{S} \believes \fresh{n\textsubscript{s+1}}, \textnormal{S} \believes \textnormal{C} \oncesaid (CMD,n\textsubscript{s+1}) } 
        {\textnormal{S} \believes \textnormal{C} \believes (CMD,n\textsubscript{s+1})}\]
Let's analyze the Message 7 to prove that also the Respond Message has been produced in this execution of the protocol.

\[ \frac{\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}, \textnormal{C} \sees \lbrace RESP, n\textsubscript{c+1} \rbrace \textsubscript{K\textsubscript{sess}}}{ \textnormal{C} \believes \textnormal{S} \oncesaid (RESP,n\textsubscript{c+1})} 
\]

\[ \frac{\textnormal{C} \believes \textnormal{C} \sharekey{sess } \textnormal{S}, \textnormal{C} \believes \textnormal{S} \oncesaid (RESP,n\textsubscript{c+1}) }{\textnormal{C} \believes \textnormal{S} \believes (RESP,n\textsubscript{c+1})}
\]
After the exchange of messages 6 and 7 we have proven that:
\begin{itemize}
	\item \( \textnormal{S} \believes \textnormal{C} \believes CMD\)
	\item \( \textnormal{C} \believes \textnormal{S} \believes RESP\)
\end{itemize}
Note that nonces are updated on every exchange of CMD and RESP message to avoid the possibility of reply attack. Furthermore note that in the real protocol the hash-mac is used also in messages 6 and 7 just to check integrity of messages. However it does not add anything more in the description of formal protocol so it was ignored it these messages.
