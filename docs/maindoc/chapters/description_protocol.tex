\chapter{Description of the protocol}
\section{Introduction}
   The protocol developed in this project has been designed to garantee secrecy, integrity and authentication. \\
   The overall protocol is based on public encrypt. Infact we suppose that the client already has the public key of the server stored on
   its filesystem. The public encryption scheme allows to authenticate the server. It also allows to exchange a secret master key wich is used by symmetric ciphers to encrpyt the following communications. It is also used an HMAC to garantee integrity and nonces to garantee freshness of communications.
\section{Sequence Diagram}
\begin{sequencediagram}
	\def\unitfactor{1}
	\newinst[0]{cl}{:Client}
	\newinst[11]{sr}{:Server}
	\mess{cl}{\small1) ClientHello,n\textsubscript{c}}{sr}
	\mess{sr}{\small2) ServerHello,n\textsubscript{s}}{cl}
	\mess{sr}{\small3) \(\lbrace\)n\textsubscript{c},n\textsubscript{s}\(\rbrace\)\textsubscript{K\textsubscript{priv}}}{cl}
	\mess{cl}{\small4) \(\lbrace\)n\textsubscript{s},K\textsubscript{sess},K\textsubscript{mac},Username,Password\(\rbrace\)\textsubscript{K\textsubscript{publ}}}{sr}
	\mess{sr}{\small5) Authentication OK,HMAC\textsubscript{K\textsubscript{mac}}(Authentication OK)}{cl}
	\mess{cl}{\small6) \(\lbrace\)Command,n\textsubscript{s+1}\(\rbrace\)\textsubscript{K\textsubscript{sess}}, HMAC\textsubscript{K\textsubscript{mac}}(\(\lbrace\)Command,n\textsubscript{s+1}\(\rbrace\)\textsubscript{K\textsubscript{sess}})}{sr}
	\mess{sr}{\small7) \(\lbrace\)Response,n\textsubscript{c+1}\(\rbrace\)\textsubscript{K\textsubscript{sess}},HMAC\textsubscript{K\textsubscript{mac}}(\(\lbrace\)Response,n\textsubscript{c+1}\(\rbrace\)\textsubscript{K\textsubscript{sess}})}{cl}
\end{sequencediagram}

%\section{BAN Logic}
\newcommand{\believes}{\mid\equiv}
\newcommand{\sees}{\triangleleft}
\newcommand{\oncesaid}{\mid\sim}
\newcommand{\controls}{\Rightarrow}
\newcommand{\fresh}[1]{\#(#1)}
\newcommand{\combine}[2]{{\langle #1 \rangle}_{#2}}
\newcommand{\encrypt}[2]{{ \{ #1 \} }_{#2}}
\newcommand{\sharekey}[1]{\xleftrightarrow{#1}}
\newcommand{\pubkey}[1]{\xmapsto{#1}}
\newcommand{\secret}[1]{\xleftrightharpoons{#1}}

%\[A \believes B \]
%\[A \sees B \]
%\[A \oncesaid B \]
%\[A \controls B \]
%\[\fresh{X}\]
%\[\combine{X}{Y}\]
%\[\encrypt{X}{Y}\]
%\[A \sharekey{k} B \]
%\[\pubkey{k} B\]
%\[A \secret{k} B\]

\section{Formal Description}
\paragraph{Ipothesis}
\[\textnormal{Client} \believes \fresh{n_c}\]
\[\textnormal{Server} \believes \fresh{n_s}\]
\[\textnormal{Client} \believes \textnormal{Server} \controls n_s\]
\[\textnormal{Server} \believes \textnormal{Client} \controls n_c\]
\[\textnormal{Client} \believes \pubkey{K\textsubscript{publ}} \textnormal{Server}\]
\[\textnormal{Server} \believes \textnormal{Client} \controls K_{session}\]
\[\textnormal{Server} \believes \textnormal{Client} \secret{password} \textnormal{Server}\]

\paragraph{Objectives}
\[\textnormal{Client} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
\[\textnormal{Server} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
%\[\textnormal{Client} \believes \textnormal{Server} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
%\[\textnormal{Server} \believes \textnormal{Client} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
\[\textnormal{Server} \believes \fresh{\textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}}\]
\[\textnormal{Sever} \believes \textnormal{Client}\believes CMD\]
\[\textnormal{Client} \believes \textnormal{Server}\believes RESP\]

\paragraph{Idealized Protocol}
\[\textnormal{M3: Server} \rightarrow \textnormal{Client} \lbrace n_c,n_s \rbrace \textsubscript{priv} \]
\[\textnormal{M4: Client} \rightarrow \textnormal{Server} \lbrace n_s,\textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server} ,Username,Password \rbrace \textsubscript{publ}\]
\[\textnormal{M6: Client} \rightarrow \textnormal{Server} \lbrace CMD,n\textsubscript{s+1} \rbrace \textsubscript{K\textsubscript{sees}}\]
\[\textnormal{M7: Server} \rightarrow \textnormal{Client} \lbrace RESP,n\textsubscript{c+1} \rbrace \textsubscript{K\textsubscript{sess}}\]

\paragraph{Proof}\mbox{} \\

\par In message 3 the client receives the two nonces encrypted with server's private key. If we apply the Message Meaning Rule (1st postulate) we derive
\[ \frac{\textnormal{C} \believes \pubkey{K\textsubscript{publ}} \textnormal{S}, 	\textnormal{C} \sees \lbrace n_c,n_s \rbrace \textsubscript{K\textsubscript{priv}}}
        {\textnormal{C} \believes \textnormal{S} \oncesaid (n_c,n_s)}  \]
By applying the Nonce Verification Rule (2nd postulate) we derive
\[ \frac{\textnormal{C} \believes \fresh{n_c}, \textnormal{C} \believes \textnormal{S} \oncesaid (n_s,n_c)}{\textnormal{C} \believes (n_c,n_s)} \]

\[ \frac{\textnormal{C} \believes (n_c,n_s)}{\textnormal{C} \believes n_c, \textnormal{C} \believes n_s} \]
So after message 3 the client knows the server nonce generated in this instance of protocol. In the message 4 the client sends the K\textsubscript{sess}, and authenticates to the Server. Client and Server have a preshared secret wich is the Password linked to Username. We apply the Message Meaning Rule (1st postulate) to M4.
\[ \frac{\textnormal{S} \believes \textnormal{C} \secret{passw} \textnormal{S}, \textnormal{S} \sees \combine{n_s,K\textsubscript{sess},K\textsubscript{mac},Username}{passw}}{\textnormal{S}\believes \textnormal{C} \oncesaid (n_s,K\textsubscript{sess},K\textsubscript{mac},Username)} \]
Now we apply the Nonce Verification Rule (2nd postulate) to that message.
\[ \frac{\textnormal{S}\believes \fresh{n_s}, \textnormal{S} \believes \textnormal{C} \oncesaid (n_s,K\textsubscript{sess},,K\textsubscript{mac},Username)}
   {\textnormal{S} \believes \textnormal{C} \believes (n_s,K\textsubscript{sess},K\textsubscript{mac},Username)}	\]
The Server believes that Client believes in the session key. Now we apply the Jurisdiction Rule (3rd postulate) to that message.
\[ \frac{\textnormal{S} \believes \textnormal{C} \believes (K\textsubscript{sess},K\textsubscript{mac}), \textnormal{S} \believes \textnormal{C} \controls (K\textsubscript{sess},K\textsubscript{mac})}
        {\textnormal{S} \believes (K\textsubscript{sess},K\textsubscript{mac}) } \]
Now the Server and the Client believe that session key and mac key has been generated in this execution of the protocol. We have proven that
\[ (\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}) \wedge (\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}) \]
Now the session keys are established. In the idealized protocol we assumed that the client typed the correct password so the message 5 is AUTHENTICATION OK. It is necessary to proof that commands have been generated in this execution of the protocol by analyzing message 6.
\[ \frac{\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}, \textnormal{S} \sees \lbrace CMD, n\textsubscript{s+1} \rbrace \textsubscript{K\textsubscript{sess}} }{ \textnormal{S} \believes \textnormal{C} \oncesaid (CMD,n\textsubscript{s+1}) }\]

\[ \frac{ \textnormal{S} \believes \fresh{n\textsubscript{s+1}}, \textnormal{S} \believes \textnormal{C} \oncesaid (CMD,n\textsubscript{s+1}) } 
        {\textnormal{S} \believes \textnormal{C} \believes (CMD,n\textsubscript{s+1})}\]
Let's analyze the Message 7 to prove that also the Respond Message has been produced in this execution of the protocol.

\[ \frac{\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}, \textnormal{C} \sees \lbrace RESP, n\textsubscript{c+1} \rbrace \textsubscript{K\textsubscript{sess}}}{ \textnormal{C} \believes \textnormal{S} \oncesaid (RESP,n\textsubscript{c+1})} 
\]

\[ \frac{\textnormal{C} \believes \textnormal{C} \sharekey{sess } \textnormal{S}, \textnormal{C} \sees \lbrace RESP,n\textsubscript{c+1} \rbrace \textsubscript{K\textsubscript{sess}} }{\textnormal{C} \believes \textnormal{S} \believes (RESP,n\textsubscript{c+1})}
\]
Note that nonces are updated on every exchange of CMD and RESP message to avoid the possibility of reply attack.
