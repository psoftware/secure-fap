\chapter{Description of the protocol}
\section{Introduction}
   
   The protocol developed in this project has been designed to garantee secrecy, integrity and authentication for a client-server application. 

   The overall protocol is based on asymmetric encryption. Infact we suppose that the client already has the public key of the server stored on
   its filesystem. The public encryption scheme allows to authenticate the server. The assumption is that just the server knows the private key so, when the client receives a message signed with private key, it is sure that the server has sent it. But, as we know, the asymmetric encryption is too slow so it is used just at beginning to exchange the \textit{session key} and the \textit{mac key}. The first one is used by symmetric cipher to garantee secrecy of communication, the second one is used to garantee integrity. The client is authenticated by application with a login, after the \textit{key exchange} so we assume that client and the server also share a secret quantity wich is the \textit{password}.
\section{Sequence Diagram}
\par In this paragraph we will see the sequence diagram.
\begin{sequencediagram}
	\def\unitfactor{1}
	\newinst[0]{cl}{Client}
	\newinst[11]{sr}{Server}
	\mess{cl}{\small1) ClientHello || n\textsubscript{c}}{sr}
	\mess{sr}{\small2) ServerHello || n\textsubscript{s}}{cl}
	\mess{sr}{\small3) E(K\textsubscript{priv}, n\textsubscript{c} || n\textsubscript{s})}{cl}
	\mess{cl}{\small4) E(K\textsubscript{publ}, n\textsubscript{s} || K\textsubscript{sess} || K\textsubscript{mac} || Username || Password)}{sr}
	\mess{sr}{\small5) Authentication OK || HMAC\textsubscript{K\textsubscript{mac}}(Authentication OK)}{cl}
	\mess{cl}{\small6) E(K\textsubscript{sess}, Command || n\textsubscript{s+1}) || 

	HMAC\textsubscript{K\textsubscript{mac}}(E(K\textsubscript{sess}, Command || n\textsubscript{s+1}))	}{sr}
	\mess{sr}{\small7) E(K\textsubscript{sess}, Response || n\textsubscript{c+1}) || HMAC\textsubscript{K\textsubscript{mac}}(E(K\textsubscript{sess}, Response || n\textsubscript{c+1})}{cl}
\end{sequencediagram}

%\section{BAN Logic}
\newcommand{\believes}{\mid\equiv}
\newcommand{\sees}{\triangleleft}
\newcommand{\oncesaid}{\mid\sim}
\newcommand{\controls}{\Rightarrow}
\newcommand{\fresh}[1]{\#(#1)}
\newcommand{\combine}[2]{{\langle #1 \rangle}_{#2}}
\newcommand{\encrypt}[2]{{ \{ #1 \} }_{#2}}
\newcommand{\sharekey}[1]{\xleftrightarrow{#1}}
\newcommand{\pubkey}[1]{\xmapsto{#1}}
\newcommand{\secret}[1]{\xleftrightharpoons{#1}}

%\[A \believes B \]
%\[A \sees B \]
%\[A \oncesaid B \]
%\[A \controls B \]
%\[\fresh{X}\]
%\[\combine{X}{Y}\]
%\[\encrypt{X}{Y}\]
%\[A \sharekey{k} B \]
%\[\pubkey{k} B\]
%\[A \secret{k} B\]

\section{Formal Description}
\paragraph{Ipothesis}
\[\textnormal{Client} \believes \fresh{n_c}\]
\[\textnormal{Server} \believes \fresh{n_s}\]
\[\textnormal{Client} \believes \textnormal{Server} \controls n_s\]
\[\textnormal{Server} \believes \textnormal{Client} \controls n_c\]
\[\textnormal{Client} \believes \pubkey{K\textsubscript{publ}} \textnormal{Server}\]
\[\textnormal{Server} \believes \textnormal{Client} \controls K_{session}\]
\[\textnormal{Server} \believes \textnormal{Client} \secret{password} \textnormal{Server}\]

\paragraph{Objectives}
\[\textnormal{Client} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
\[\textnormal{Server} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
%\[\textnormal{Client} \believes \textnormal{Server} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
%\[\textnormal{Server} \believes \textnormal{Client} \believes \textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}\]
\[\textnormal{Server} \believes \fresh{\textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server}}\]
\[\textnormal{Sever} \believes \textnormal{Client}\believes CMD\]
\[\textnormal{Client} \believes \textnormal{Server}\believes RESP\]

\paragraph{Idealized Protocol}
\[\textnormal{M3: Server} \rightarrow \textnormal{Client} \lbrace n_c,n_s \rbrace \textsubscript{priv} \]
\[\textnormal{M4: Client} \rightarrow \textnormal{Server} \lbrace n_s,\textnormal{Client} \sharekey{K\textsubscript{sess }} \textnormal{Server} ,Username,Password \rbrace \textsubscript{publ}\]
\[\textnormal{M6: Client} \rightarrow \textnormal{Server} \lbrace CMD,n\textsubscript{s+1} \rbrace \textsubscript{K\textsubscript{sees}}\]
\[\textnormal{M7: Server} \rightarrow \textnormal{Client} \lbrace RESP,n\textsubscript{c+1} \rbrace \textsubscript{K\textsubscript{sess}}\]

\paragraph{Proof}\mbox{} \\

\par In message 3 the client receives the two nonces encrypted with server's private key. If we apply the Message Meaning Rule (1st postulate) we derive
\[ \frac{\textnormal{C} \believes \pubkey{K\textsubscript{publ}} \textnormal{S}, 	\textnormal{C} \sees \lbrace n_c,n_s \rbrace \textsubscript{K\textsubscript{priv}}}
        {\textnormal{C} \believes \textnormal{S} \oncesaid (n_c,n_s)}  \]
By applying the Nonce Verification Rule (2nd postulate) we derive
\[ \frac{\textnormal{C} \believes \fresh{n_c}, \textnormal{C} \believes \textnormal{S} \oncesaid (n_s,n_c)}{\textnormal{C} \believes (n_c,n_s)} \]

\[ \frac{\textnormal{C} \believes (n_c,n_s)}{\textnormal{C} \believes n_c, \textnormal{C} \believes n_s} \]
So after message 3 the client knows the server nonce generated in this instance of protocol. In the message 4 the client sends the K\textsubscript{sess}, and authenticates to the Server. Client and Server have a preshared secret wich is the Password linked to Username. We apply the Message Meaning Rule (1st postulate) to M4.
\[ \frac{\textnormal{S} \believes \textnormal{C} \secret{passw} \textnormal{S}, \textnormal{S} \sees \combine{n_s,K\textsubscript{sess},K\textsubscript{mac},Username}{passw}}{\textnormal{S}\believes \textnormal{C} \oncesaid (n_s,K\textsubscript{sess},K\textsubscript{mac},Username)} \]
Now we apply the Nonce Verification Rule (2nd postulate) to that message.
\[ \frac{\textnormal{S}\believes \fresh{n_s}, \textnormal{S} \believes \textnormal{C} \oncesaid (n_s,K\textsubscript{sess},,K\textsubscript{mac},Username)}
   {\textnormal{S} \believes \textnormal{C} \believes (n_s,K\textsubscript{sess},K\textsubscript{mac},Username)}	\]
The Server believes that Client believes in the session key. Now we apply the Jurisdiction Rule (3rd postulate) to that message.
\[ \frac{\textnormal{S} \believes \textnormal{C} \believes (K\textsubscript{sess},K\textsubscript{mac}), \textnormal{S} \believes \textnormal{C} \controls (K\textsubscript{sess},K\textsubscript{mac})}
        {\textnormal{S} \believes (K\textsubscript{sess},K\textsubscript{mac}) } \]
Now the Server and the Client believe that session key and mac key has been generated in this execution of the protocol. We have proven that
\[ (\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}) \wedge (\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}) \]
Now the session keys are established. In the idealized protocol we assumed that the client typed the correct password so the message 5 is AUTHENTICATION OK. It is necessary to proof that commands have been generated in this execution of the protocol by analyzing message 6.
\[ \frac{\textnormal{S} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}, \textnormal{S} \sees \lbrace CMD, n\textsubscript{s+1} \rbrace \textsubscript{K\textsubscript{sess}} }{ \textnormal{S} \believes \textnormal{C} \oncesaid (CMD,n\textsubscript{s+1}) }\]

\[ \frac{ \textnormal{S} \believes \fresh{n\textsubscript{s+1}}, \textnormal{S} \believes \textnormal{C} \oncesaid (CMD,n\textsubscript{s+1}) } 
        {\textnormal{S} \believes \textnormal{C} \believes (CMD,n\textsubscript{s+1})}\]
Let's analyze the Message 7 to prove that also the Respond Message has been produced in this execution of the protocol.

\[ \frac{\textnormal{C} \believes \textnormal{C} \sharekey{K\textsubscript{sess }} \textnormal{S}, \textnormal{C} \sees \lbrace RESP, n\textsubscript{c+1} \rbrace \textsubscript{K\textsubscript{sess}}}{ \textnormal{C} \believes \textnormal{S} \oncesaid (RESP,n\textsubscript{c+1})} 
\]

\[ \frac{\textnormal{C} \believes \textnormal{C} \sharekey{sess } \textnormal{S}, \textnormal{C} \sees \lbrace RESP,n\textsubscript{c+1} \rbrace \textsubscript{K\textsubscript{sess}} }{\textnormal{C} \believes \textnormal{S} \believes (RESP,n\textsubscript{c+1})}
\]
Note that nonces are updated on every exchange of CMD and RESP message to avoid the possibility of reply attack.
