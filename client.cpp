#include "commonlib/net_wrapper.h"
#include "commonlib/messages.h"
#include "commonlib/commonlib.h"

#include <string.h>
#include <stdio.h>
#include <errno.h>

#include <fcntl.h>
#include <unistd.h>

#include <openssl/evp.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/err.h>

uint64_t cl_nonce;
uint64_t sr_nonce;

uint64_t cl_seq_num;
uint64_t sr_seq_num;

uint64_t generate_nonce()
{
	uint64_t nonce;
	RAND_bytes((unsigned char*)&nonce,8);
	return nonce;
}

void generate_session_key(unsigned char key[])
{
	RAND_bytes(key, 16);
}

void generate_iv(unsigned char iv[])
{
	RAND_bytes(iv, 16);
}

int send_hello_msg(int sock) {
	hello_msg h;
	h.t = CLIENT_HELLO;
	h.nonce = cl_nonce = cl_seq_num = generate_nonce();
	convert_to_network_order(&h);
	printf("client sends nonce: %ld\n",cl_nonce);
	return send_data(sock,(unsigned char*)&h, sizeof(h));
}

int analyze_message(unsigned char* buf)
{
	convert_to_host_order(buf);
	switch( ((simple_msg*)buf)->t ) {
  		case SERVER_HELLO:
  			sr_nonce = sr_seq_num = ((hello_msg*)buf)->nonce;
  			printf("Server nonce received: %ld\n",sr_nonce);
  			break;
		default:
			return -2;
	}

	return 0;
}

unsigned int divide_upper(unsigned int dividend, unsigned int divisor)
{
    return 1 + ((dividend - 1) / divisor);
}

int main(int argc, char **argv)
{
	ERR_load_crypto_strings();

	int sd;
	uint16_t server_port;

	my_buffer my_buff;
	my_buff.buf = NULL;
	my_buff.size = 0;

	// Parsing parameters
	if( argc < 3 ){
		perror("use: ./client filename server_ip port");
		return -1;
	}
	sscanf(argv[3],"%hd",&server_port);

	sd = start_tcp_connection(argv[2], server_port);
	if( sd < 0 )
		return -1;

	// 1) Send Client Nuance
	send_hello_msg(sd);

	// 2) Get Server Nuance
	recv_data(sd,&my_buff);
	analyze_message(my_buff.buf);

	// 3) Verify Server Identity
	// receive E(Kpriv, client_nonce|server_nonce)
	unsigned int signature_len = recv_data(sd, &my_buff);
	unsigned char *signature = new unsigned char[signature_len];
	memcpy(signature, my_buff.buf, signature_len);

	SignatureVerifier sv("keys/rsa_server_pubkey.pem");

	unsigned char expected_signed[16];
	memcpy(expected_signed, &cl_nonce, 8);
	memcpy(expected_signed + 8, &sr_nonce, 8);
	sv.verify(expected_signed, 16);

	if(!sv.verify_end(signature, signature_len))
	{
		printf("Signature not verified!\n");
		return -1;
	}

	printf("Server Authentication Success!\n");

	// compare nonces

	// 4) Send client verification infos and KeySession
	unsigned char auth_username[] = "username";
	unsigned char auth_secret[] = "passwordbella";
	// generate session key
	unsigned char session_key[16];
	generate_session_key(session_key);

	// setup PublicKey cipher
	EncryptSession asymm_authclient_cipher("keys/rsa_server_pubkey.pem");

	// ## plaintext data
	// send iv and encrypted key generated by EncryptSession
	unsigned char *auth_iv = asymm_authclient_cipher.get_iv();
	unsigned char *auth_pk_encrypted_key;
	unsigned int auth_pk_encrypted_key_len = asymm_authclient_cipher.get_session_key(&auth_pk_encrypted_key);
	send_data(sd, auth_pk_encrypted_key, auth_pk_encrypted_key_len);
	send_data(sd, auth_iv, EVP_CIPHER_iv_length(EVP_aes_128_cbc()));

	// ## ciphered data
	unsigned char *auth_plaintext = new unsigned char[8 + 16 + sizeof(auth_username) + sizeof(auth_secret)];
	unsigned int auth_plaintext_size = 0;
	// client nonce encrypt
	memcpy(auth_plaintext, (unsigned char*)&sr_nonce, 8);
	auth_plaintext_size += 8;
	// session key encrypt
	memcpy(auth_plaintext + auth_plaintext_size, session_key, 16);
	auth_plaintext_size += 16;
	// username encrypt
	memcpy(auth_plaintext + auth_plaintext_size, auth_username, sizeof(auth_username));
	auth_plaintext_size += sizeof(auth_username);
	// password encrypt
	memcpy(auth_plaintext + auth_plaintext_size, auth_secret, sizeof(auth_secret));
	auth_plaintext_size += sizeof(auth_secret);

	// encrypt all
	unsigned char *auth_ciphertext;
	unsigned int auth_cipherlen =
		asymm_authclient_cipher.encrypt(auth_plaintext, auth_plaintext_size, &auth_ciphertext);

	unsigned char *auth_ciphertext_padding;
	unsigned int auth_cipherlen_padding =
		asymm_authclient_cipher.encrypt_end(&auth_ciphertext_padding);

	// send client auth header (server needs sizes)
	client_auth auth_header_msg = {CLIENT_AUTHENTICATION,
		auth_cipherlen + auth_cipherlen_padding, sizeof(auth_username), sizeof(auth_secret)};
	printf("client header: ciphertext_len = %u, username_length = %u, password_length = %u\n",
		auth_header_msg.total_ciphertext_size, auth_header_msg.username_length, auth_header_msg.password_length);

	convert_to_network_order(&auth_header_msg);
	send_data(sd, (unsigned char*)&auth_header_msg, sizeof(auth_header_msg));

	// send ciphertext and padded ciphertext
	send_data(sd, auth_ciphertext, auth_cipherlen);
	send_data(sd, auth_ciphertext_padding, auth_cipherlen_padding);

	// 5) Waiting for AuthOK or AuthFailed
	simple_msg auth_response_msg;
	recv_data(sd, &my_buff);
	memcpy(&auth_response_msg, my_buff.buf, sizeof(auth_response_msg));

	if(auth_response_msg.t == AUTHENTICATION_FAILED)
	{
		printf("Authentication Failed!\n");
		return -1;
	}

	printf("Authentication success!\n");

	// 6) Send Command
	char command_str[] = "DOWNLOAD 4kporn.mkv";

	unsigned char *command_iv = new unsigned char[EVP_CIPHER_iv_length(EVP_aes_128_cbc())];
	generate_iv(command_iv);
	send_data(sd, command_iv, EVP_CIPHER_iv_length(EVP_aes_128_cbc()));

	SymmetricCipher sc(EVP_aes_128_cbc(), session_key, command_iv);

	// build plaintext to make seqnum|command_str
	unsigned char *command_concat_str = new unsigned char[sizeof(sr_seq_num) + strlen(command_str) + 1];
	memcpy(command_concat_str, (unsigned char*)&sr_seq_num, sizeof(sr_seq_num));
	memcpy(command_concat_str + sizeof(sr_seq_num), (unsigned char*)&command_str, strlen(command_str) + 1);

	// make ciphertext from seqnum|command_str
	unsigned char *command_ciphertext;
	unsigned int command_cipherlen = sc.encrypt(command_concat_str, sizeof(sr_seq_num) + strlen(command_str) + 1, &command_ciphertext);
	unsigned char *command_ciphertext_end;
	unsigned int command_cipherlen_end = sc.encrypt_end(&command_ciphertext_end);

	unsigned char *command_concat_ciphertext = new unsigned char[command_cipherlen + command_cipherlen_end];
	memcpy(command_concat_ciphertext, command_ciphertext, command_cipherlen);
	memcpy(command_concat_ciphertext + command_cipherlen, command_ciphertext_end, command_cipherlen_end);

	// send {seqnum|command_str}_Ksess
	send_data(sd, command_concat_ciphertext, command_cipherlen + command_cipherlen_end);

	// make hmac from {seqnum|command_str}_Ksess
	unsigned char *hash_result;
	unsigned int hash_len;

	HMACMaker hc(session_key, 16);
	hc.hash(command_concat_ciphertext, command_cipherlen + command_cipherlen_end);
	hash_len = hc.hash_end(&hash_result);

	// send HMAC_Ksess{ eqnum|command_str}_Ksess }
	send_data(sd, hash_result, hash_len);

	// increment server sequence number
	sr_seq_num++;

	// 7) Receive Response

	// ----------------------------------------------------------------


	// Start PublicKey Session
	EncryptSession ss("keys/rsa_server_pubkey.pem");

	unsigned char *iv = ss.get_iv();
	unsigned char *pk_encrypted_key;
	unsigned int pk_encrypted_key_len = ss.get_session_key(&pk_encrypted_key);

	send_data(sd, pk_encrypted_key, pk_encrypted_key_len);
	send_data(sd, iv, EVP_CIPHER_iv_length(EVP_aes_128_cbc()));

	// getting file size
	FILE *fp;
	unsigned int filesize = open_file_r(argv[1], &fp);
	unsigned int chunk_count = divide_upper(filesize, CHUNK_SIZE);
	printf("File size = %u, Chunk size = %d, Chunk count = %d\n", filesize, CHUNK_SIZE, chunk_count);

	// send to server chunk transfer details
	send_file_msg s_msg = {SEND_FILE, CHUNK_SIZE, chunk_count + 1};  // +1 for padding
	convert_to_network_order(&s_msg);
	send_data(sd, (unsigned char*)&s_msg, sizeof(s_msg));

	unsigned char datachunk[CHUNK_SIZE];
	for(unsigned int i=0; i<chunk_count; i++)
	{
		// read next chunk from file
		unsigned int chunk_plainlen = fread(datachunk, 1, CHUNK_SIZE, fp);
		printf("encrypting chunk of %d plaintext bytes\n", chunk_plainlen);

		// do encryption
		unsigned char *chunk_ciphertext;
		unsigned int chunk_cipherlen = ss.encrypt(datachunk, chunk_plainlen, &chunk_ciphertext);

		// send encrypted data
		printf("sending chunk(%d) of %d bytes\n", i, chunk_cipherlen);
		send_data(sd, chunk_ciphertext, chunk_cipherlen);
		delete[] chunk_ciphertext;

		// if last chunk
		if(i==chunk_count-1)
		{
			// compute padding
			unsigned char *padding_ciphertext;
			unsigned int padding_cipherlen;
			padding_cipherlen = ss.encrypt_end(&padding_ciphertext);

			// send padding
			printf("sending padding of %d bytes\n", padding_cipherlen);
			send_data(sd, padding_ciphertext, padding_cipherlen);
			delete[] padding_ciphertext;
		}
	}

	printf("session_key: ");
	print_hex(pk_encrypted_key, pk_encrypted_key_len);
	printf("iv: ");
	print_hex(iv, EVP_CIPHER_iv_length(EVP_aes_128_cbc()));
	//printf("ciphertext: ");
	//print_hex(ciphertext, cipherlen);

	close(sd);

	return 0;
}
